Реализация немного отошла от задачи. Batch обработка запускается не при вызове эндпоинта, а при получении события из Kafka.

Последовательность:
- пользователь отправляет запрос в приложение [event-producer](event-producer)
- приложение [event-producer](event-producer) получает запрос и отправляет событие в Kafka
- приложение [kafka-batch](kafka-batch) читает событие из Kafka и вызывает job-batch

## Особенности кастомных span
* Если span'ы начинаются и завершаются слишком быстро, SDK не гарантирует их отправку до завершения.
* Если создавать span в BatchConfiguration для reader, processor и writer, то там только создаются объекты(не выполняются),
* и сразу же закрывается span в try-finally, а затем в методах возвращаете бины без дальнейших действий.
* Это значит, что span охватывает только создание объекта, но не выполнение чтения, обработки и записи.
* Рекомендуется создавать spans вокруг реальной логики, а не вокруг создания бина.


## Размышления по поводу трэсинга(tracing)
Идея видеть последовательность вызовов и понимать, где произошли задержки или ошибки понятна.
Теоретически это помогает с разбором инцидентов. Но когда начинаешь реализовывать tracing сталкиваешься со следующими проблемами:
- внедрение. Кажется чем это отличается от других продуктов, но думаю к tracing надо относиться, как к отдельному продукту, который не только надо внедрить, но и поддерживать
- данные. Данные о трэйсинге надо где-то хранить. Чтобы трэсинг был полезен нужно собирать много данных. Система хранения должна учитывать это.
- для работы приложения нужно больше памяти и CPU. Соответственно если к приложению были претензии по производительности, то tracing только усугубит проблему.
- если трэйсинг укажет на проблему, т.е. мы получим место(сервис) и время, для выяснения причины сбой необходимо найти логи и проанализировать их. Встает вопрос: если бы не было трэйсинга, как долго бы мы выясняли место и время?
- Что трэйсить? Если трейсить все вызовы методов, то получится большой объем не нужной информации. Если же добавлять трейсинг только основных методов, то это ложится на плечи разработчиков. Код станет менее понятным. Потенциально возможно больше багов.

С другой стороны иметь какой-нибудь идентификатор, по которому можно найти все логи было бы хорошо. Может организовывать так приложение, что:
- на всех точках входа в приложение будет или получаться идентификатор трейса, если он есть, или создаваться идентификатор, который будет логироваться вместе с обычными логами;
- на всех выходах будет передаваться ранее полученный или созданный идентификатор.

```shell
docker rmi event-producer
#docker build -t event-producer ./event-producer
```


```shell
curl -X POST http://localhost:8080/send_event \
     -H 'Content-Type: application/json' \
     -d '{"event": "test_event", "value": 123}'
```


